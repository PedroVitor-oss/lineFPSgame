<style>
    body {
        margin: 0;
        overflow: hidden;
        background-color: black;
    }

    #minimapa {
        scale: 0.5;
        transform: translate(-50%, -50%);
    }

    #game3d {
        position: absolute;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        width: 100vw;
        height: 100vh;
        z-index: -1;
    }

    .ui {
        position: absolute;
        top: 0;
        z-index: 2;
        width: 100vw;
        height: 100vh;
    }

    #mira {
        position: absolute;
        z-index: 5;
        top: 50vh;
        left: 50vw;
        transform: translate(-50%, -50%);
        width: 30px;


    }

    .placar {
        display: flex;
        position: absolute;
        top: 10px;
        left: 50vw;
        transform: translateX(-50%);
        background: rgb(39, 52, 78);
        width: 200px;
        height: 50px;

        & h1 {
            color: #fff;
            margin: 6%;
        }

        & .me {
            text-align: center;
            background-color: rgb(115, 115, 255);
            width: 90px;
            margin-right: 20px;

        }

        & .other {
            text-align: center;
            background-color: rgb(255, 115, 115);
            width: 90px;

        }
    }

    .player-info {
        position: absolute;
        bottom: 20px;
        left: 20px;
        z-index: 2;
        display: flex;

        & .info {
            & h2 {
                padding-left: 4px;
                margin: 0;
            }

            & span {
                width: 200px;
                display: block;
                height: 20px;
                background: #43ff43;
            }
        }

        & .arma {
            width: 50px;
            height: 50px;
            background: transparent;
            border: 7px solid orange;
            display: flex;
            justify-content: center;
            align-items: center;
            transform: rotate(45deg);

            & .color {
                width: 70%;
                height: 70%;
                background: red;
            }


        }
    }


    .tremer {
        animation: tremer 0.1s;
    }

    .damage-indicator {
        position: absolute;
        width: 100vw;
        height: 100vh;
        z-index: 10;;
        background-color: red;
        animation: fadeout .5s;
        opacity:0;
        top:0
    }
    @keyframes fadeout {
        0% {
            opacity: 1;
        }
        100% {
            opacity: 0;
        }
    }

    @keyframes tremer {
        0% {
            transform: translate(0);
        }

        25% {
            transform: translate(-0, -2px);
        }

        50% {
            transform: translate(0px, 2px);
        }

        75% {
            transform: translate(-0px, 2px);
        }

        100% {
            transform: translate(0);
        }
    }
</style>

<canvas id="minimapa" width="400" height="400"></canvas>
<canvas id="game3d" width="1000" height="600"></canvas>
<div class="ui">
    <img src="/img/mira.svg" alt="" srcset="" id="mira">
    <div class="placar">
        <div class="me">
            <h1>0</h1>
        </div>
        <div class="other">
            <h1>0</h1>
        </div>
    </div>

    <div class="player-info">
        <div class="arma">
            <div class="color"></div>
        </div>
        <div class="info">
            <h2>PlayerID : </h2>
            <span class="hp"></span>
        </div>
    </div>

    <span id="player-list"></span>
</div>

<!-- classes -->

<script>

    class Player {
        constructor(name, x, y) {
            this.group = 'default';
            this.health = 200;
            this.name = name;
            this.x = x;
            this.y = y;
            this.size = 5
            this.a = 0;//angle
            this.speed = 1;
            this.coliders = [];
        }
        draw(ctx) {
            ctx.fillStyle = "blue";
            //triangulo
            ctx.beginPath();
            // Ponto central do triângulo
            const centerX = this.x;
            const centerY = this.y;

            // Tamanho do triângulo
            const size = 10;

            // Ângulo em radianos (converta de graus se necessário: angleInRadians = angleInDegrees * Math.PI/180)
            const angle = this.a; // ângulo em radianos

            // Calcular os três pontos do triângulo
            const point1X = centerX + size * Math.cos(angle);
            const point1Y = centerY + size * Math.sin(angle);

            const point2X = centerX + size / 2 * Math.cos(angle + 2.1); // 120 graus (2π/3)
            const point2Y = centerY + size / 2 * Math.sin(angle + 2.1);

            const point3X = centerX + size / 2 * Math.cos(angle - 2.1); // -120 graus (-2π/3)
            const point3Y = centerY + size / 2 * Math.sin(angle - 2.1);

            // Desenhar o triângulo
            ctx.moveTo(point1X, point1Y);
            ctx.lineTo(point2X, point2Y);
            ctx.lineTo(point3X, point3Y);
            ctx.closePath();
            ctx.fill();
        }

        Rotate(angle) {
            this.a += 0.05 * angle;
        }
        HorizontalMove(mult) {
            this.x += Math.cos(this.a + (90 * Math.PI / 180)) * this.speed * mult;
            //check collision with boxes
            this.coliders.forEach(box => {
                if (this.x < box.x + box.width &&
                    this.x + this.size > box.x &&
                    this.y < box.y + box.height &&
                    this.y + this.size > box.y) {
                    // Collision detected
                    this.x -= Math.cos(this.a + (90 * Math.PI / 180)) * this.speed * mult;
                }
            });

            this.y += Math.sin(this.a + (90 * Math.PI / 180)) * this.speed * mult;

            //check collision with boxes
            this.coliders.forEach(box => {
                if (this.x < box.x + box.width &&
                    this.x + this.size > box.x &&
                    this.y < box.y + box.height &&
                    this.y + this.size > box.y) {
                    // Collision detected
                    this.y -= Math.sin(this.a + (90 * Math.PI / 180)) * this.speed * mult;
                }
            });
        }
        Move(mult) {
            this.x += Math.cos(this.a) * this.speed * mult;


            //check collision with boxes
            this.coliders.forEach(box => {
                if (this.x < box.x + box.width &&
                    this.x + this.size > box.x &&
                    this.y < box.y + box.height &&
                    this.y + this.size > box.y) {
                    // Collision detected
                    this.x -= Math.cos(this.a) * this.speed * mult;
                }
            });
            this.y += Math.sin(this.a) * this.speed * mult;

            //check collision with boxes
            this.coliders.forEach(box => {
                if (this.x < box.x + box.width &&
                    this.x + this.size > box.x &&
                    this.y < box.y + box.height &&
                    this.y + this.size > box.y) {
                    // Collision detected
                    this.y -= Math.sin(this.a) * this.speed * mult;
                }
            });

        }
        SetColiders(colider) {
            this.coliders = colider;
        }
    }

    class Box {
        constructor(x, y, width, height, color, border) {
            this.x = x;
            this.y = y;
            this.width = width;
            this.height = height;
            this.color = color;
            this.border = border;
        }

        draw(ctx) {
            ctx.fillStyle = this.color;
            ctx.fillRect(this.x, this.y, this.width, this.height);
            ctx.strokeStyle = this.border;

        }
    }

    class MiniMap {
        constructor() {
            this.boxes = [];
        }
        GetColiders() {
            return this.boxes;
        }

        AddBox(box) {
            this.boxes.push(box);
        }

        draw(ctx) {
            this.boxes.forEach(box => box.draw(ctx));
        }
    }

    class InputControle {
        constructor() {
            this.keys = {};
            document.addEventListener('keydown', (event) => {
                this.keys[event.key] = true;
            });
            document.addEventListener('keyup', (event) => {
                this.keys[event.key] = false;
            });
        }

        isKeyPressed(key) {
            return this.keys[key] || false;
        }
    }

    class Raycast {
        constructor(x, y, angle, maxDistance, coliders) {
            this.x = x;
            this.y = y;
            this.angle = angle;
            this.maxDistance = maxDistance;
            this.coliders = coliders;


            this.hit = false;

            for (let i = 0; i < this.maxDistance; i++) {
                const rayX = this.x + Math.cos(this.angle) * i;
                const rayY = this.y + Math.sin(this.angle) * i;

                for (const colider of this.coliders) {
                    if (rayX > colider.x && rayX < colider.x + colider.width &&
                        rayY > colider.y && rayY < colider.y + colider.height) {
                        this.hit = true;
                        break;
                    }
                }

                if (this.hit) {
                    this.endPointX = rayX;
                    this.endPointY = rayY;
                    break;
                }
            }

            if (this.hit === false) {
                this.endPointX = this.x + Math.cos(this.angle) * this.maxDistance;
                this.endPointY = this.y + Math.sin(this.angle) * this.maxDistance;
            }
            this.distHit = Math.hypot(this.endPointX - this.x, this.endPointY - this.y);
        }
        draw(ctx) {
            ctx.strokeStyle = "orange";
            ctx.beginPath();
            ctx.moveTo(this.x, this.y);
            ctx.lineTo(this.endPointX, this.endPointY);
            ctx.stroke();
        }
    }

</script>
<!-- mini mapa -->
<script src="https://cdn.socket.io/4.8.1/socket.io.min.js"
    integrity="sha384-mkQ3/7FUtcGyoppY6bz/PORYoGqOl7/aSUMn2ymDOJcapfS6PHqxhRTMh1RR0Q6+"
    crossorigin="anonymous"></script>
<script>
    const socket = io();
    let positionStarted ;
    const player = new Player("you", 176, 43);
     let pontosp1 = 0;
    let pontosp2 = 0;
    let playersInGame = [];
    socket.on("connect", () => {
        console.log("Conectado ao servidor com ID:", socket);
    });

    socket.on("setMydata", data => {
        player.x = data.x;
        player.y = data.y;
        player.name = data.name;
        player.group = data.group;

        $(".info h2").text(`Player: ${player.name} - Group: ${player.group}`);

        positionStarted = {x:player.x, y:player.y};
    })

    socket.on("newPlayer", (players) => {
        $("#player-list").html(`${players.length}`)
        //console.log("Jogadores atuais:", players);
        playersInGame = []
        for (p of players) {
            if (p.name != player.name) {
                let np = new Player(p.name,p.x,p.y);
                np.group = p.group;
                playersInGame.push(np);
            }
        }
        // otherPlayers = players.filter(p => p.name !== "you");
    });
        
    socket.on("playerHit", (data) => {
        if (data.name === player.name) {
            // Aplica dano ao jogador
            player.health -= data.damage;

            $("span.hp").width(`${player.health}px`);
            $("body").append("<div class='damage-indicator'></div>");
            if (player.health <= 0) {
                // O jogador morreu
                socket.emit("playerDied",{group:player.group=='blue'?"red":"blue"});
                player.health = 200;
                player.x = positionStarted.x;   
                player.y = positionStarted.y;
            }
        }
    })

    socket.on("pontoFOR", (group) => {
        if (group == 'blue') {
            pontosp1++;
            $(".placar .me h1").html(pontosp1)
        } else {
            pontosp2++;
            $(".placar .other h1").html(pontosp2)
        }
    })
</script>


<script>
    const canvas = document.getElementById("minimapa");
    const ctx = canvas.getContext("2d");
    const canvas3d = document.getElementById("game3d");
    const ctx3d = canvas3d.getContext("2d");

   

    let centerY = 0;

    let tiro = false;

    const miniMapa = new MiniMap();

    const Input = new InputControle();
    //const otherPlayer = new Player("other", 212, 380);

    //freeze mouse end no show him
    document.addEventListener("mousedown", (event) => {
        canvas3d.requestPointerLock();
        tiro = true;
        //alert("tiro")
    });
    document.addEventListener("mousemove", (event) => {
        const movementX = event.movementX || 0;
        player.Rotate(movementX * 0.1);
        centerY -= event.movementY || 0;
    });

    function Setup() {

        //create parede
        miniMapa.AddBox(new Box(0, 0.75403088, 150.94513, 75.757355, "white", "black"));
        miniMapa.AddBox(new Box(150.94513, 0.75403088, 66.643684, 18.796942, "white", "black"));
        miniMapa.AddBox(new Box(217.58882, 0.75403088, 63.79567, 70.63092, "white", "black"));
        miniMapa.AddBox(new Box(281.38452, 0.75403088, 128.61549, 101.95915, "white", "black"));
        miniMapa.AddBox(new Box(345.69223, 102.7132, 64.307739, 224.99365, "white", "black"));
        miniMapa.AddBox(new Box(275.11884, 327.70682, 134.88113, 37.593891, "white", "black"));
        miniMapa.AddBox(new Box(250.62587, 357.32626, 159.3741, 60.37804, "white", "black"));
        miniMapa.AddBox(new Box(0, 76.511383, 16.11084, 78.906723, "white", "black"));
        miniMapa.AddBox(new Box(0, 155.41811, 31.41614, 84.581924, "white", "black"));
        miniMapa.AddBox(new Box(0, 240, 22.319239, 70.3339, "white", "black"));
        miniMapa.AddBox(new Box(0, 310.33389, 74.618156, 21.929796, "white", "black"));
        miniMapa.AddBox(new Box(68.637306, 332.2637, 87.43425, 32.752239, "white", "black"));
        miniMapa.AddBox(new Box(156.07155, 365.0159, 31.328241, 52.688396, "white", "black"));
        miniMapa.AddBox(new Box(156.07155, 417.70432, 119.04729, 39.302719, "white", "black"));
        miniMapa.AddBox(new Box(158.9196, 102.14358, 46.080406, 127.59132, "white", "black"));
        miniMapa.AddBox(new Box(222.71524, 102.14358, 50.125172, 25.062593, "white", "black"));
        miniMapa.AddBox(new Box(222.71524, 139.73747, 58.669254, 26.201792, "white", "black"));
        miniMapa.AddBox(new Box(240.37296, 165.93927, 71.200531, 63.79565, "white", "black"));
        miniMapa.AddBox(new Box(133.57219, 136.31984, 25.347406, 52.403591, "white", "black"));
        miniMapa.AddBox(new Box(111.64243, 136.31984, 21.929756, 26.201796, "white", "black"));
        miniMapa.AddBox(new Box(111.64243, 104.13718, 27.910612, 20.220947, "white", "black"));
        miniMapa.AddBox(new Box(53.542797, 136.31984, 40.157101, 26.201796, "white", "black"));
        miniMapa.AddBox(new Box(53.542797, 162.52162, 27.910606, 110.78801, "white", "black"));
        miniMapa.AddBox(new Box(81.453407, 210.36839, 32.467442, 77.181374, "white", "black"));
        miniMapa.AddBox(new Box(133.57219, 204.67233, 12.673703, 86.010239, "white", "black"));
        miniMapa.AddBox(new Box(146.24588, 250.52547, 58.754112, 40.157101, "white", "black"));
        miniMapa.AddBox(new Box(181.13414, 325.14365, 54.112396, 18.796942, "white", "black"));
        miniMapa.AddBox(new Box(198.22226, 301.22028, 49.270767, 23.923382, "white", "black"));
        miniMapa.AddBox(new Box(242.36661, 253.08871, 30.473827, 27.341003, "white", "black"));
        miniMapa.AddBox(new Box(265.15076, 280.42969, 31.328234, 20.790535, "white", "black"));
        miniMapa.AddBox(new Box(287.08051, 227.17169, 9.3984814, 31.043432, "white", "black"));

        player.SetColiders(miniMapa.GetColiders());
    }

    function Draw() {
        $(".me h1").html(pontosp1)
        ctx.reset();
        ctx3d.reset();
        //brackground
        ctx.fillStyle = "#bf925dff";
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        //background #D
        ctx3d.fillStyle = "#0b021699";
        ctx3d.fillRect(0, 0, canvas3d.width, canvas3d.height);
        //chao
        for (let i = 0; i < canvas3d.height - ((canvas3d.height / 2) + centerY); i += 10) {
            const darkness = Math.min(1, i / (canvas3d.height / 2)); // 0 a 1
            //rgb(162, 89, 255)
            // Escurecer a cor azul baseado na distância
            const red = Math.floor(162 * (darkness));
            const green = Math.floor(89 * (darkness));
            const blue = Math.floor(255 * (darkness)); // Azul escurece
            ctx3d.fillStyle = `rgb(${red}, ${green}, ${blue})`;
            ctx3d.fillRect(0, ((canvas3d.height / 2) + centerY) + i, canvas3d.width, 10);
        }


        miniMapa.draw(ctx);
        for (play of playersInGame) {
            play.draw(ctx);
        }

        player.draw(ctx);
        //otherPlayer.draw(ctx);

        //raycast
        let FOV = 1;
        for (let i = -30; i <= 30; i += 0.5) {
            const ray = new Raycast(player.x, player.y, player.a + (i * (Math.PI / 180)), 100, player.coliders);
            //ray.draw(ctx);

            // draw 3d
            const distance = ray.distHit;
            const wallHeight = (100 / distance) * 100;

            // Calcular cor baseada na distância (quanto mais longe, mais escuro)
            const maxDistance = 100; // Distância máxima para escurecimento
            const darkness = Math.min(1, distance / maxDistance); // 0 a 1
            //rgba(144, 59, 255, 0.6)
            // Escurecer a cor azul baseado na distância
            const red = Math.floor(144 * (1 - darkness));
            const green = Math.floor(59 * (1 - darkness));
            const blue = Math.floor(255 * (1 - darkness)); // Azul escurece

            ctx3d.fillStyle = `rgb(${red}, ${green}, ${blue})`;
            ctx3d.fillRect((i + 30) * canvas3d.width / (60),
                ((canvas3d.height - wallHeight) / 2) + centerY,
                canvas3d.width / (60),
                wallHeight);

            //render players in 3d
            colidersPLayers = [];
            for (const p of playersInGame) {
                colidersPLayers.push(new Box(p.x, p.y, p.size, p.size, "blue", "black"));
            }
            const rayObj = new Raycast(player.x, player.y, player.a + (i * (Math.PI / 180)), 100, colidersPLayers);
            if (rayObj.hit && rayObj.distHit < ray.distHit) {
// Encontrar o player atingido
                        let playerAcertado = null;
                        for (let idx = 0; idx < playersInGame.length; idx++) {
                            const p = playersInGame[idx];
                            // Verifica se a posição do impacto está dentro do player
                            if (
                                rayObj.endPointX >= p.x &&
                                rayObj.endPointX <= p.x + p.size &&
                                rayObj.endPointY >= p.y &&
                                rayObj.endPointY <= p.y + p.size
                            ) {
                                playerAcertado = p;
                                break;
                            }
                        }

                if (tiro) {
                    if (i > -1.5 && i < 1.5) {
                        
                        if (playerAcertado) {
                            console.log(playerAcertado)
                            console.log(playersInGame)
                            tiro = false;
                            socket.emit("playerShot", { shooter: player.name, target: playerAcertado.name });
                        }
                    }
                }
                const distance = rayObj.distHit;
                const wallHeight = (100 / distance) * 100;
                ctx3d.fillStyle = playerAcertado.group;
                ctx3d.fillRect((i + 30) * canvas3d.width / (60),
                    ((canvas3d.height - wallHeight) / 2) + centerY,
                    canvas3d.width / (60),
                    wallHeight);
            }

        }


        tiro = false;
        //moviment
        if (Input.isKeyPressed("a")) {
            player.HorizontalMove(-1);
        }
        if (Input.isKeyPressed("d")) {
            player.HorizontalMove(1);
        }
        if (Input.isKeyPressed("w")) {
            player.Move(1);
        }
        if (Input.isKeyPressed("s")) {
            player.Move(-1);
        }

        socket.emit("playerMovement", player);

    }





    Setup();
    setInterval(Draw, 1000 / 60);


    /*
       const rects = document.querySelectorAll('rect');
   let output = '';
   rects.forEach(rect =>{
   const x = rect.getAttribute('x');
   const y = rect.getAttribute('y');
   const width = rect.getAttribute('width');
   const height = rect.getAttribute('height');
   output+=`miniMapa.AddBox(new Box(${x}, ${y}, ${width}, ${height}, "white", "black"));\n`;
   });
   console.log(output);*/
</script>