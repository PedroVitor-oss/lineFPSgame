<link rel="stylesheet" href="/css/game.css">

<canvas id="minimapa" width="400" height="400"></canvas>
<canvas id="game3d" width="1000" height="600"></canvas>
<div class="container">
    <h1>Parabéns! A equipe</h1>
    <div class="winner-name" id="winner-team">Vencedora</div>
    <h1>ganhou o jogo!</h1>

    <!-- SVG do Troféu -->
   
    <p class="celebrations">Celebremos esta grande vitória!</p>

    <a href="/" class="btn-home">Voltar ao Início</a>
</div>
<div class="ui">
    <img src="/img/mira.svg" alt="" srcset="" id="mira">
    <div class="placar">
        <div class="me">
            <h1>0</h1>
        </div>
        <div class="other">
            <h1>0</h1>
        </div>
    </div>

    <div class="player-info">
        <div class="arma">
            <div class="color"></div>
        </div>
        <div class="info">
            <h2>PlayerID : </h2>
            <span class="hp"></span>
        </div>
    </div>

    <div class="pause">
        <h1>Pause</h1>
        <div class="cont-input">
            <input type="text" id="surname" placeholder="Apelido">
            <button onclick="SetSurname()">Mudar Nome</button>
        </div>
        <div class="cont-input">
            <span class="title">Sensitivity</span>
            <input type="range" name="sencible" id="sencible" minlength="1" maxlength="100" value="10">
        </div>
        <button onclick="ClosePauseMenu()">fechar menu pause</button>
    </div>




    <div class="playes-list">
        <table>
            <thead>
                <tr>
                    <th>blue group</th>
                    <th>red group</th>
                </tr>
            </thead>
            <tbody>

            </tbody>
        </table>
    </div>
</div>

<!-- classes -->

<script>
    class ShootingEffectSystem {
        constructor(ctx3d, canvas3d) {
            this.ctx = ctx3d;
            this.canvas = canvas3d;
            this.effects = [];
            this.muzzleFlashIntensity = 0;
            this.screenShakeIntensity = 0;
            this.screenShakeOffset = { x: 0, y: 0 };
        }

        // Chamar esta função quando o jogador atirar
        triggerShot() {
            // Efeito de flash na arma
            this.muzzleFlashIntensity = 1.0;

            // Efeito de tremor de tela
            this.screenShakeIntensity = 5;

            // Adicionar efeito de traço balístico
            this.addTracerEffect();

            // Adicionar partículas de fumaça
            this.addSmokeParticles();
        }

        addTracerEffect() {
            // Criar um traço balístico que desaparece gradualmente
            this.effects.push({
                type: 'tracer',
                life: 1.0, // Vida máxima do efeito (em segundos)
                width: 2,
                color: 'rgba(255, 200, 50, 0.8)',
                // O traço vai do centro da tela para frente
                startX: this.canvas.width / 2,
                startY: this.canvas.height / 2,
                // Direção aleatória levemente para simular recuo
                endX: this.canvas.width / 2 + (Math.random() * 10 - 5),
                endY: this.canvas.height / 2 - 20 + (Math.random() * 4 - 2)
            });
        }

        addSmokeParticles() {
            // Adicionar várias partículas de fumaça
            for (let i = 0; i < 8; i++) {
                this.effects.push({
                    type: 'smoke',
                    life: 1.5 + Math.random() * 0.5,
                    x: this.canvas.width / 2 + (Math.random() * 10 - 5),
                    y: this.canvas.height / 2 + (Math.random() * 6 - 3),
                    size: 3 + Math.random() * 4,
                    speedX: (Math.random() - 0.5) * 2,
                    speedY: -2 - Math.random() * 2,
                    color: `rgba(150, 150, 150, ${0.3 + Math.random() * 0.2})`
                });
            }
        }

        update(deltaTime) {
            // Atualizar tremor de tela
            if (this.screenShakeIntensity > 0) {
                this.screenShakeOffset = {
                    x: (Math.random() - 0.5) * this.screenShakeIntensity,
                    y: (Math.random() - 0.5) * this.screenShakeIntensity
                };
                this.screenShakeIntensity -= deltaTime * 10;
            } else {
                this.screenShakeOffset = { x: 0, y: 0 };
            }

            // Atualizar flash da arma
            if (this.muzzleFlashIntensity > 0) {
                this.muzzleFlashIntensity -= deltaTime * 5;
            }

            // Atualizar e remover efeitos expirados
            for (let i = this.effects.length - 1; i >= 0; i--) {
                const effect = this.effects[i];
                effect.life -= deltaTime;

                if (effect.life <= 0) {
                    this.effects.splice(i, 1);
                    continue;
                }

                // Atualizar posição das partículas de fumaça
                if (effect.type === 'smoke') {
                    effect.x += effect.speedX;
                    effect.y += effect.speedY;
                    // A fumaça sobe e se expande
                    effect.size += deltaTime * 5;
                    effect.speedX *= 0.95; // Resistência do ar
                }
            }
        }

        render() {
            // Aplicar tremor de tela
            this.ctx.save();
            this.ctx.translate(this.screenShakeOffset.x, this.screenShakeOffset.y);

            // Renderizar flash da arma
            if (this.muzzleFlashIntensity > 0) {
                this.renderMuzzleFlash();
            }

            // Renderizar todos os efeitos
            this.effects.forEach(effect => {
                if (effect.type === 'tracer') {
                    this.renderTracer(effect);
                } else if (effect.type === 'smoke') {
                    this.renderSmoke(effect);
                }
            });

            this.ctx.restore();
        }

        renderMuzzleFlash() {
            const centerX = this.canvas.width / 2;
            const centerY = this.canvas.height / 2;
            const intensity = this.muzzleFlashIntensity;

            // Flash principal (círculo brilhante)
            const gradient = this.ctx.createRadialGradient(
                centerX, centerY, 0,
                centerX, centerY, 20 * intensity
            );
            gradient.addColorStop(0, `rgba(255, 255, 200, ${intensity * 0.8})`);
            gradient.addColorStop(0.5, `rgba(255, 200, 50, ${intensity * 0.4})`);
            gradient.addColorStop(1, `rgba(255, 150, 0, 0)`);

            this.ctx.fillStyle = gradient;
            this.ctx.beginPath();
            this.ctx.arc(centerX, centerY, 20 * intensity, 0, Math.PI * 2);
            this.ctx.fill();

            // Raios de luz
            this.ctx.strokeStyle = `rgba(255, 200, 100, ${intensity * 0.6})`;
            this.ctx.lineWidth = 1.5;

            for (let i = 0; i < 8; i++) {
                const angle = (i / 8) * Math.PI * 2;
                const length = 25 + Math.random() * 15;

                this.ctx.beginPath();
                this.ctx.moveTo(centerX, centerY);
                this.ctx.lineTo(
                    centerX + Math.cos(angle) * length * intensity,
                    centerY + Math.sin(angle) * length * intensity
                );
                this.ctx.stroke();
            }
        }

        renderTracer(effect) {
            const alpha = effect.life; // O traço desaparece gradualmente

            this.ctx.strokeStyle = effect.color;
            this.ctx.lineWidth = effect.width;
            this.ctx.lineCap = 'round';
            this.ctx.globalAlpha = alpha;

            this.ctx.beginPath();
            this.ctx.moveTo(effect.startX, effect.startY);
            this.ctx.lineTo(effect.endX, effect.endY);
            this.ctx.stroke();

            this.ctx.globalAlpha = 1;
        }

        renderSmoke(effect) {
            const alpha = effect.life; // A fumaça desaparece gradualmente

            this.ctx.fillStyle = effect.color;
            this.ctx.globalAlpha = alpha * 0.7;

            this.ctx.beginPath();
            this.ctx.arc(effect.x, effect.y, effect.size, 0, Math.PI * 2);
            this.ctx.fill();

            this.ctx.globalAlpha = 1;
        }
    }
    class Player {
        constructor(name, x, y) {
            this.group = 'default';
            this.health = 200;
            this.name = name;
            this.surname;
            this.x = x;
            this.y = y;
            this.size = 5
            this.a = 0;//angle
            this.speed = 1;
            this.coliders = [];
        }
        setSurname(surname) {
            this.surname = surname;
            socket.emit("setSurname", surname);
        }
        draw(ctx) {
            ctx.fillStyle = "blue";
            //triangulo
            ctx.beginPath();
            // Ponto central do triângulo
            const centerX = this.x;
            const centerY = this.y;

            // Tamanho do triângulo
            const size = 10;

            // Ângulo em radianos (converta de graus se necessário: angleInRadians = angleInDegrees * Math.PI/180)
            const angle = this.a; // ângulo em radianos

            // Calcular os três pontos do triângulo
            const point1X = centerX + size * Math.cos(angle);
            const point1Y = centerY + size * Math.sin(angle);

            const point2X = centerX + size / 2 * Math.cos(angle + 2.1); // 120 graus (2π/3)
            const point2Y = centerY + size / 2 * Math.sin(angle + 2.1);

            const point3X = centerX + size / 2 * Math.cos(angle - 2.1); // -120 graus (-2π/3)
            const point3Y = centerY + size / 2 * Math.sin(angle - 2.1);

            // Desenhar o triângulo
            ctx.moveTo(point1X, point1Y);
            ctx.lineTo(point2X, point2Y);
            ctx.lineTo(point3X, point3Y);
            ctx.closePath();
            ctx.fill();
        }

        Rotate(angle) {
            this.a += 0.05 * angle;
        }
        HorizontalMove(mult) {
            this.x += Math.cos(this.a + (90 * Math.PI / 180)) * this.speed * mult;
            //check collision with boxes
            this.coliders.forEach(box => {
                if (this.x < box.x + box.width &&
                    this.x + this.size > box.x &&
                    this.y < box.y + box.height &&
                    this.y + this.size > box.y) {
                    // Collision detected
                    this.x -= Math.cos(this.a + (90 * Math.PI / 180)) * this.speed * mult;
                }
            });

            this.y += Math.sin(this.a + (90 * Math.PI / 180)) * this.speed * mult;

            //check collision with boxes
            this.coliders.forEach(box => {
                if (this.x < box.x + box.width &&
                    this.x + this.size > box.x &&
                    this.y < box.y + box.height &&
                    this.y + this.size > box.y) {
                    // Collision detected
                    this.y -= Math.sin(this.a + (90 * Math.PI / 180)) * this.speed * mult;
                }
            });
        }
        Move(mult) {
            this.x += Math.cos(this.a) * this.speed * mult;


            //check collision with boxes
            this.coliders.forEach(box => {
                if (this.x < box.x + box.width &&
                    this.x + this.size > box.x &&
                    this.y < box.y + box.height &&
                    this.y + this.size > box.y) {
                    // Collision detected
                    this.x -= Math.cos(this.a) * this.speed * mult;
                }
            });
            this.y += Math.sin(this.a) * this.speed * mult;

            //check collision with boxes
            this.coliders.forEach(box => {
                if (this.x < box.x + box.width &&
                    this.x + this.size > box.x &&
                    this.y < box.y + box.height &&
                    this.y + this.size > box.y) {
                    // Collision detected
                    this.y -= Math.sin(this.a) * this.speed * mult;
                }
            });

        }
        SetColiders(colider) {
            this.coliders = colider;
        }
    }

    class Box {
        constructor(x, y, width, height, color, border) {
            this.x = x;
            this.y = y;
            this.width = width;
            this.height = height;
            this.color = color;
            this.border = border;
        }

        draw(ctx) {
            ctx.fillStyle = this.color;
            ctx.fillRect(this.x, this.y, this.width, this.height);
            ctx.strokeStyle = this.border;

        }
    }

    class MiniMap {
        constructor() {
            this.boxes = [];
        }
        GetColiders() {
            return this.boxes;
        }

        AddBox(box) {
            this.boxes.push(box);
        }

        draw(ctx) {
            this.boxes.forEach(box => box.draw(ctx));
        }
    }

    class InputControle {
        constructor() {
            this.keys = {};
            this.keysPrevious = {};
            this.keysPressedThisFrame = {};

            document.addEventListener('keydown', (event) => {
                // Previne comportamento padrão para teclas comuns de jogos
                if (['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight', ' ', 'Escape'].includes(event.key)) {
                    event.preventDefault();
                }

                this.keys[event.key] = true;

                // Marca que a tecla foi pressionada neste frame
                if (!this.keysPrevious[event.key]) {
                    this.keysPressedThisFrame[event.key] = true;
                }
            });

            document.addEventListener('keyup', (event) => {
                this.keys[event.key] = false;
            });
        }

        // Atualiza o estado das teclas (deve ser chamado no final de cada frame)
        update() {
            // Salva o estado atual para o próximo frame
            this.keysPrevious = { ...this.keys };

            // Limpa as teclas pressionadas neste frame
            this.keysPressedThisFrame = {};
        }

        // Verifica se a tecla está pressionada no momento
        isKeyPressed(key) {
            return this.keys[key] || false;
        }

        // Verifica se a tecla foi pressionada exatamente neste frame
        keyDown(key) {
            return this.keysPressedThisFrame[key] || false;
        }

        // Verifica se a tecla foi liberada neste frame
        keyUp(key) {
            return this.keysPrevious[key] && !this.keys[key];
        }

        // Método auxiliar para verificar múltiplas teclas de uma vez
        anyKeyPressed(keys) {
            return keys.some(key => this.isKeyPressed(key));
        }

        // Método auxiliar para verificar se alguma tecla foi pressionada neste frame
        anyKeyDown(keys) {
            return keys.some(key => this.keyDown(key));
        }
    }


    class Raycast {
        constructor(x, y, angle, maxDistance, coliders) {
            this.x = x;
            this.y = y;
            this.angle = angle;
            this.maxDistance = maxDistance;
            this.coliders = coliders;


            this.hit = false;

            for (let i = 0; i < this.maxDistance; i++) {
                const rayX = this.x + Math.cos(this.angle) * i;
                const rayY = this.y + Math.sin(this.angle) * i;

                for (const colider of this.coliders) {
                    if (rayX > colider.x && rayX < colider.x + colider.width &&
                        rayY > colider.y && rayY < colider.y + colider.height) {
                        this.hit = true;
                        break;
                    }
                }

                if (this.hit) {
                    this.endPointX = rayX;
                    this.endPointY = rayY;
                    break;
                }
            }

            if (this.hit === false) {
                this.endPointX = this.x + Math.cos(this.angle) * this.maxDistance;
                this.endPointY = this.y + Math.sin(this.angle) * this.maxDistance;
            }
            this.distHit = Math.hypot(this.endPointX - this.x, this.endPointY - this.y);
        }
        draw(ctx) {
            ctx.strokeStyle = "orange";
            ctx.beginPath();
            ctx.moveTo(this.x, this.y);
            ctx.lineTo(this.endPointX, this.endPointY);
            ctx.stroke();
        }
    }

    class PointControl {
        constructor(id, x, y, b, r) {
            this.id = id;

            this.x = x;
            this.y = y;

            this.influenceBlue = 0;
            this.influenceRed = 0;

        }
        draw(ctx) {
            ctx.fillStyle = "yellow";
            ctx.beginPath();
            ctx.arc(this.x, this.y, 10, 0, Math.PI * 2);
            ctx.fill();

            ctx.fillStyle = "blue";
            ctx.fillRect(this.x - 10, this.y - 20, 20 * (this.influenceBlue / 100), 5);

            ctx.fillStyle = "red";
            ctx.fillRect(this.x - 10, this.y - 10, 20 * (this.influenceRed / 100), 5);
        }

    }

</script>
<!-- mini mapa -->
<script src="https://cdn.socket.io/4.8.1/socket.io.min.js"
    integrity="sha384-mkQ3/7FUtcGyoppY6bz/PORYoGqOl7/aSUMn2ymDOJcapfS6PHqxhRTMh1RR0Q6+"
    crossorigin="anonymous"></script>

<script src="/js/conectionSocket.js"></script>
<script>
    function ClosePauseMenu() {
        $(".pause").css("display", "none");
        sencible = $("#sencible").val() / 100;
        pause = false;
        console.log("sencible", sencible)
        canvas3d.requestPointerLock();
    }
    function SetSurname() {
        let nname = $("#surname").val();
        player.surname = nname;
    }
</script>


<script>
    const canvas = document.getElementById("minimapa");
    const ctx = canvas.getContext("2d");
    const canvas3d = document.getElementById("game3d");
    const ctx3d = canvas3d.getContext("2d");
    let pause = true;
    let savenumplayers = 0;
    let sencible = 0.1;
    let centerY = 0;

    const effectSystem = new ShootingEffectSystem(ctx3d, canvas3d);


    let tiro = false;

    const miniMapa = new MiniMap();

    const Input = new InputControle();
    //const otherPlayer = new Player("other", 212, 380);

    //freeze mouse end no show him
    document.addEventListener("mousedown", (event) => {
        if (!pause && !finishGame) {
            canvas3d.requestPointerLock();
            tiro = true;
            effectSystem.triggerShot();

        }
        //alert("tiro")
    });
    document.addEventListener("mousemove", (event) => {
        if (!pause) {
            const movementX = event.movementX || 0;
            //console.log("player antes da sencible",player)
            player.Rotate(movementX * sencible);
            centerY -= (event.movementY || 0);
        }
    });

    function Setup() {

        //create parede
        miniMapa.AddBox(new Box(0, 0.75403088, 150.94513, 75.757355, "white", "black"));
        miniMapa.AddBox(new Box(150.94513, 0.75403088, 66.643684, 18.796942, "white", "black"));
        miniMapa.AddBox(new Box(217.58882, 0.75403088, 63.79567, 70.63092, "white", "black"));
        miniMapa.AddBox(new Box(281.38452, 0.75403088, 128.61549, 101.95915, "white", "black"));
        miniMapa.AddBox(new Box(345.69223, 102.7132, 64.307739, 224.99365, "white", "black"));
        miniMapa.AddBox(new Box(275.11884, 327.70682, 134.88113, 37.593891, "white", "black"));
        miniMapa.AddBox(new Box(250.62587, 357.32626, 159.3741, 60.37804, "white", "black"));
        miniMapa.AddBox(new Box(0, 76.511383, 16.11084, 78.906723, "white", "black"));
        miniMapa.AddBox(new Box(0, 155.41811, 31.41614, 84.581924, "white", "black"));
        miniMapa.AddBox(new Box(0, 240, 22.319239, 70.3339, "white", "black"));
        miniMapa.AddBox(new Box(0, 310.33389, 74.618156, 21.929796, "white", "black"));
        miniMapa.AddBox(new Box(68.637306, 332.2637, 87.43425, 32.752239, "white", "black"));
        miniMapa.AddBox(new Box(156.07155, 365.0159, 31.328241, 52.688396, "white", "black"));
        miniMapa.AddBox(new Box(156.07155, 417.70432, 119.04729, 39.302719, "white", "black"));
        miniMapa.AddBox(new Box(158.9196, 102.14358, 46.080406, 127.59132, "white", "black"));
        miniMapa.AddBox(new Box(222.71524, 102.14358, 50.125172, 25.062593, "white", "black"));
        miniMapa.AddBox(new Box(222.71524, 139.73747, 58.669254, 26.201792, "white", "black"));
        miniMapa.AddBox(new Box(240.37296, 165.93927, 71.200531, 63.79565, "white", "black"));
        miniMapa.AddBox(new Box(133.57219, 136.31984, 25.347406, 52.403591, "white", "black"));
        miniMapa.AddBox(new Box(111.64243, 136.31984, 21.929756, 26.201796, "white", "black"));
        miniMapa.AddBox(new Box(111.64243, 104.13718, 27.910612, 20.220947, "white", "black"));
        miniMapa.AddBox(new Box(53.542797, 136.31984, 40.157101, 26.201796, "white", "black"));
        miniMapa.AddBox(new Box(53.542797, 162.52162, 27.910606, 110.78801, "white", "black"));
        miniMapa.AddBox(new Box(81.453407, 210.36839, 32.467442, 77.181374, "white", "black"));
        miniMapa.AddBox(new Box(133.57219, 204.67233, 12.673703, 86.010239, "white", "black"));
        miniMapa.AddBox(new Box(146.24588, 250.52547, 58.754112, 40.157101, "white", "black"));
        miniMapa.AddBox(new Box(181.13414, 325.14365, 54.112396, 18.796942, "white", "black"));
        miniMapa.AddBox(new Box(198.22226, 301.22028, 49.270767, 23.923382, "white", "black"));
        miniMapa.AddBox(new Box(242.36661, 253.08871, 30.473827, 27.341003, "white", "black"));
        miniMapa.AddBox(new Box(265.15076, 280.42969, 31.328234, 20.790535, "white", "black"));
        miniMapa.AddBox(new Box(287.08051, 227.17169, 9.3984814, 31.043432, "white", "black"));

        player.SetColiders(miniMapa.GetColiders());
    }

    function Draw() {
        if (!finishGame) {

            $(".me h1").html(pontosp1)
            ctx.reset();
            ctx3d.reset();
            //brackground
            ctx.fillStyle = "#bf925dff";
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            //background #D
            ctx3d.fillStyle = "#0b021699";
            ctx3d.fillRect(0, 0, canvas3d.width, canvas3d.height);

            if (savenumplayers != playersInGame.length) {
                savenumplayers = playersInGame.length;

            }

            if (Input.keyUp("Escape")) {
                pause = !pause;
                $(".pause").css("display", "flex");
                canvas3d.requestPointerLock();
                console.log("pause");
            }
            let quantIwinn = 0;
            for (let p of pointsControl) {
                //let allPlayer = [];
                let allPlayer = [...playersInGame, player];

                //                console.log(allPlayer)
                for (let otherPlayer of allPlayer) {


                    //se distancia do player para pointcontrol < 30 somar no grupo dele
                    if (Math.hypot(otherPlayer.x - p.x, otherPlayer.y - p.y) < 30) {
                        {{!-- console.log("other player in point control") --}}
                        if (otherPlayer.group == 'blue') {
                            p.influenceBlue += 60 / 500;
                            if (p.influenceBlue > 100) p.influenceBlue = 100;
                            p.influenceRed -= 60 / 500;
                            if (p.influenceRed < 0) p.influenceRed = 0;

                            if(player == otherPlayer){
                               // console.log("player is otherPlayer soma vida? influenceblue",p.influenceBlue);
                                if(p.influenceBlue>50){
                                //console.log("player is otherPlayer soma vida?")
                                    player.health+= player.health<200? 1:0;
                                    $("span.hp").width(`${player.health}px`);
                                }
                            }

                        } else {
                            p.influenceRed += 60 / 500;
                            if (p.influenceRed > 100) p.influenceRed = 100;
                            p.influenceBlue -= 60 / 500;
                            if (p.influenceBlue < 0) p.influenceBlue = 0;

                             if(player == otherPlayer){
                                //console.log("player is otherPlayer soma vida? influencered",p.influenceRed)
                                if(p.influenceRed>50){
                               
                                    player.health+= player.health<200? 1:0;
                                    $("span.hp").width(`${player.health}px`);
                                }
                            }
                        }

                        

                        //socket.emit("addPointControl", p);
                    }
                }
                p.draw(ctx);

                if (player.group == "blue") {
                    if (p.influenceBlue > 90) {
                        quantIwinn++;
                    }
                } else {
                    if (p.influenceRed > 90) {
                        quantIwinn++;
                    }
                }
            }

            if (quantIwinn >= 5) {
                socket.emit("canIwin", pointsControl);
            }
            //chao
            for (let i = 0; i < canvas3d.height - ((canvas3d.height / 2) + centerY); i += 10) {
                const darkness = Math.min(1, i / (canvas3d.height / 2)); // 0 a 1
                //rgb(162, 89, 255)
                // Escurecer a cor azul baseado na distância
                const red = Math.floor(162 * (darkness));
                const green = Math.floor(89 * (darkness));
                const blue = Math.floor(255 * (darkness)); // Azul escurece
                ctx3d.fillStyle = `rgb(${red}, ${green}, ${blue})`;
                ctx3d.fillRect(0, ((canvas3d.height / 2) + centerY) + i, canvas3d.width, 10);
            }


            miniMapa.draw(ctx);
            for (play of playersInGame) {
                if (play.group == player.group)
                    play.draw(ctx);
            }

            player.draw(ctx);

            //otherPlayer.draw(ctx);

            //raycast
            let FOV = 1;
            for (let i = -30; i <= 30; i += 0.5) {
                const ray = new Raycast(player.x, player.y, player.a + (i * (Math.PI / 180)), 100, player.coliders);
                //ray.draw(ctx);

                // draw 3d
                const distance = ray.distHit;
                const wallHeight = (100 / distance) * 100;

                // Calcular cor baseada na distância (quanto mais longe, mais escuro)
                const maxDistance = 100; // Distância máxima para escurecimento
                const darkness = Math.min(1, distance / maxDistance); // 0 a 1
                //rgba(144, 59, 255, 0.6)
                // Escurecer a cor azul baseado na distância
                const red = Math.floor(144 * (1 - darkness));
                const green = Math.floor(59 * (1 - darkness));
                const blue = Math.floor(255 * (1 - darkness)); // Azul escurece

                ctx3d.fillStyle = `rgb(${red}, ${green}, ${blue})`;
                ctx3d.fillRect((i + 30) * canvas3d.width / (60),
                    ((canvas3d.height - wallHeight) / 2) + centerY,
                    canvas3d.width / (60),
                    wallHeight);

                //render players in 3d
                colidersPLayers = [];
                for (const p of playersInGame) {
                    colidersPLayers.push(new Box(p.x, p.y, p.size, p.size, "blue", "black"));
                }
                const rayObj = new Raycast(player.x, player.y, player.a + (i * (Math.PI / 180)), 100, colidersPLayers);
                if (rayObj.hit && rayObj.distHit < ray.distHit) {
                    // Encontrar o player atingido
                    let playerAcertado = null;
                    for (let idx = 0; idx < playersInGame.length; idx++) {
                        const p = playersInGame[idx];
                        // Verifica se a posição do impacto está dentro do player
                        if (
                            rayObj.endPointX >= p.x &&
                            rayObj.endPointX <= p.x + p.size &&
                            rayObj.endPointY >= p.y &&
                            rayObj.endPointY <= p.y + p.size
                        ) {
                            playerAcertado = p;
                            break;
                        }
                    }

                    if (tiro) {
                        if (i > -1.5 && i < 1.5) {

                            if (playerAcertado) {
                                console.log(playerAcertado)
                                console.log(playersInGame)
                                tiro = false;
                                socket.emit("playerShot", { shooter: player.name, target: playerAcertado.name });
                            }
                        }
                    }
                    const distance = rayObj.distHit;
                    const wallHeight = (100 / distance) * 100;
                    ctx3d.fillStyle = playerAcertado.group;
                    ctx3d.fillRect((i + 30) * canvas3d.width / (60),
                        ((canvas3d.height - wallHeight) / 2) + centerY,
                        canvas3d.width / (60),
                        wallHeight);
                }

            }

            effectSystem.render();
            tiro = false;
            //moviment
            if (Input.isKeyPressed("a")) {
                player.HorizontalMove(-1);
            }
            if (Input.isKeyPressed("d")) {
                player.HorizontalMove(1);
            }
            if (Input.isKeyPressed("w")) {
                player.Move(1);
            }
            if (Input.isKeyPressed("s")) {
                player.Move(-1);
            }

            socket.emit("playerMovement", player);

            Input.update();
            effectSystem.update(1 / 60);
        }
    }





    Setup();
    setInterval(Draw, 1000 / 60);


    /*
       const rects = document.querySelectorAll('rect');
   let output = '';
   rects.forEach(rect =>{
   const x = rect.getAttribute('x');
   const y = rect.getAttribute('y');
   const width = rect.getAttribute('width');
   const height = rect.getAttribute('height');
   output+=`miniMapa.AddBox(new Box(${x}, ${y}, ${width}, ${height}, "white", "black"));\n`;
   });
   console.log(output);*/
</script>